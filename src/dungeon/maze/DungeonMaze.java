package dungeon.maze;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import dungeon.RandomGenerator;
import dungeon.location.Collectible;
import dungeon.location.Location;
import dungeon.location.LocationType;
import dungeon.location.MazeLocation;
import dungeon.location.MovementDirection;
import dungeon.location.paths.LocationAddress;
import dungeon.location.paths.Path;
import dungeon.location.weapon.Arrow;
import dungeon.location.weapon.PunchingGloves;
import dungeon.location.weapon.CrookedArrow;
import dungeon.location.weapon.ShootResult;
import dungeon.obstacles.Berbalang;
import dungeon.obstacles.Monster;
import dungeon.obstacles.Obstacle;
import dungeon.obstacles.ObstacleType;
import dungeon.obstacles.Otyugh;
import dungeon.obstacles.Pit;
import dungeon.obstacles.Thief;
import dungeon.player.MazePlayer;
import dungeon.player.Player;

/**
 * The DungeonMaze class represents a maze within a dungeon that the player needs to travel from one
 * point to another in order to win. The player can collect treasures that are located in the caves
 * and travel through tunnels. The maze is generated by the parameters from the driver class given
 * as runtime parameters.
 */
public class DungeonMaze implements Maze {

    private static final int MINIMUM_DISTANCE_BETWEEN_START_END = 5;
    private static final int BEGINNING_ARROW_COUNT = 3;
    private final boolean wrapping;
    private final int degreeOfInterconnectivity;
    private final LocationAddress startLocation;
    private final Location[][] copyMap;
    private final int treasurePercentage;
    private final int numberOfThieves;
    private final int numberOfPits;
    private final RandomGenerator randomGenerator;
    private final int numberOfRows;
    private final int numberOfColumns;
    private final Player player;
    private final int numberOfMonsters;
    private final Map<LocationAddress, Set<LocationAddress>> adjacency;
    private final Map<LocationAddress, Set<Collectible>> locationTreasureMap;
    private final Map<LocationAddress, Set<Obstacle>> locationObstacleMap;
    private final List<LocationAddress> arrowLocations;
    private final boolean hasMovingMonster;
    private final List<Path> connectedPaths;
    private Set<LocationAddress> visitedLocations;
    private Location[][] map;
    private List<LocationAddress> indexOfCaves;
    private List<LocationAddress> indexOfLocations;
    private LocationAddress endLocation;
    private GameState gameState;
    private Berbalang berbalang;
    private boolean canMove;

    /**
     * Constructs a Dungeon Maze with the provided number of rows and columns along with the specified
     * degree of interconnectivity.
     *
     * @param numberOfRows              the number of rows in the maze.
     * @param numberOfColumns           the number of columns in the maze.
     * @param degreeOfInterconnectivity the degree of connectivity of the maze.
     * @param setWrapping               whether the maze is wrapping or not.
     * @param treasurePercentage        the minimum percentage of caves that need to have treasures.
     * @param difficulty                the number of monsters in the maze.
     * @param numberOfThieves           the number of thieves to be inserted in the dungeon.
     * @param numberOfPits              the number of pits to be inserted in the dungeon.
     * @param movingMonster             whether the dungeon would have a berbalang or not.
     */
    public DungeonMaze(int numberOfRows, int numberOfColumns, int degreeOfInterconnectivity,
                       boolean setWrapping, int treasurePercentage, int difficulty,
                       int numberOfThieves, int numberOfPits, boolean movingMonster) {
        this(numberOfRows, numberOfColumns, degreeOfInterconnectivity, setWrapping,
                treasurePercentage, difficulty, numberOfThieves, numberOfPits, movingMonster,
                new RandomGenerator()
        );
    }

    /**
     * Constructs a Dungeon Maze with the provided number of rows and columns along with the specified
     * degree of interconnectivity.
     *
     * @param numberOfRows              number of rows in the maze.
     * @param numberOfColumns           number of columns in the maze.
     * @param degreeOfInterconnectivity degree of connectivity of the maze.
     * @param setWrapping               whether the maze is wrapping or not.
     * @param treasurePercentage        the minimum percentage of caves that need to have treasures.
     * @param difficulty                the number of monsters in the maze.
     * @param numberOfThieves           the number of thieves to be inserted in the dungeon.
     * @param numberOfPits              the number of pits to be inserted in the dungeon.
     * @param movingMonster             whether the dungeon would have a berbalang or not.
     * @param randomGenerator           encapsulates the methods to generate and pick random values.
     */
    public DungeonMaze(int numberOfRows, int numberOfColumns, int degreeOfInterconnectivity,
                       boolean setWrapping, int treasurePercentage, int difficulty,
                       int numberOfThieves, int numberOfPits, boolean movingMonster,
                       RandomGenerator randomGenerator) {

        validateParameters(numberOfRows, numberOfColumns, degreeOfInterconnectivity,
                treasurePercentage, difficulty, numberOfThieves, numberOfPits);

        this.map = new Location[numberOfRows][numberOfColumns];
        this.copyMap = new Location[numberOfRows][numberOfColumns];
        this.randomGenerator = randomGenerator;
        this.wrapping = setWrapping;
        this.degreeOfInterconnectivity = degreeOfInterconnectivity;
        this.treasurePercentage = treasurePercentage;
        this.numberOfColumns = numberOfColumns;
        this.numberOfRows = numberOfRows;
        this.numberOfMonsters = difficulty;
        this.numberOfThieves = numberOfThieves;
        this.numberOfPits = numberOfPits;
        this.visitedLocations = new LinkedHashSet<>();
        this.adjacency = new LinkedHashMap<>();
        this.connectedPaths = new ArrayList<>();
        this.hasMovingMonster = movingMonster;
        this.canMove = true;
        this.locationTreasureMap = new LinkedHashMap<>();
        this.locationObstacleMap = new LinkedHashMap<>();
        this.arrowLocations = new ArrayList<>();

        generateMap(setWrapping, numberOfRows, numberOfColumns, degreeOfInterconnectivity);

        this.startLocation = indexOfCaves.get(randomGenerator.getRandomNumberBetween(0,
                indexOfCaves.size() - 1));
        this.visitedLocations.add(startLocation);
        createAdjacencyList();
        generateEndLocation();
        addMonsterToDungeon();
        addPitToDungeon();
        addThiefToDungeon();

        for (Location[] locations : map) {
            for (Location location : locations) {
                locationTreasureMap.put(location.getAddress(), location.getTreasures());
                if (location.isHasArrow()) {
                    arrowLocations.add(location.getAddress());
                }
                locationObstacleMap.put(location.getAddress(), location.getAllObstacles());
            }
        }

        if (movingMonster) {
            LocationAddress berbalangStartLocation = randomGenerator.pickNRandom(indexOfLocations, 1)
                    .get(0);
            this.berbalang = new Berbalang(100, randomGenerator, berbalangStartLocation, numberOfRows,
                    numberOfColumns, wrapping);
        }
        player = new MazePlayer(startLocation, numberOfRows, numberOfColumns, wrapping,
                BEGINNING_ARROW_COUNT, new PunchingGloves(randomGenerator));

        gameState = GameState.PLAYING;
    }


    private void addPitToDungeon() {
        if (numberOfPits != 0) {
            List<LocationAddress> potentialCavesWithPits = new ArrayList<>(indexOfCaves);
            potentialCavesWithPits.remove(startLocation);
            potentialCavesWithPits.remove(endLocation);

            potentialCavesWithPits = potentialCavesWithPits.stream().filter(locationAddress ->
                            getLocationFromAddress(locationAddress).getOtyugh() == null)
                    .collect(Collectors.toList());

            potentialCavesWithPits = randomGenerator.pickNRandom(potentialCavesWithPits,
                    Math.min(numberOfThieves, potentialCavesWithPits.size()));


            potentialCavesWithPits.forEach(locationAddress -> getLocationFromAddress(locationAddress)
                    .addPit(new Pit(locationAddress)));

        }
    }

    private void addThiefToDungeon() {
        if (numberOfThieves != 0) {
            List<LocationAddress> potentialLocationWithThief = new ArrayList<>(indexOfLocations);
            potentialLocationWithThief.remove(startLocation);
            potentialLocationWithThief.remove(endLocation);

            potentialLocationWithThief = potentialLocationWithThief.stream().filter(locationAddress ->
                            getLocationFromAddress(locationAddress).getOtyugh() == null
                                    && getLocationFromAddress(locationAddress).getPit() == null)
                    .collect(Collectors.toList());

            potentialLocationWithThief = randomGenerator.pickNRandom(potentialLocationWithThief,
                    Math.min(numberOfThieves, potentialLocationWithThief.size()));


            potentialLocationWithThief.forEach(locationAddress -> getLocationFromAddress(locationAddress)
                    .addThief(new Thief(locationAddress)));

        }
    }

    @Override
    public Location[][] getMazeMap() {
        Location[][] defensiveCopyMap = new Location[numberOfRows][numberOfColumns];

        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                defensiveCopyMap[i][j] = new MazeLocation(map[i][j]);
            }
        }

        return defensiveCopyMap;
    }

    @Override
    public void resetGame() {

        for (Location[] locations : copyMap) {
            for (Location location : locations) {
                if (locationObstacleMap.get(location.getAddress()) != null
                        && !locationObstacleMap.get(location.getAddress()).isEmpty()) {
                    locationObstacleMap.get(location.getAddress()).forEach(obstacle -> {
                        if (obstacle.getObstacleType() == ObstacleType.OTYUGH) {
                            ((Monster) obstacle).reset();
                        }
                    });
                    location.addObstacles(locationObstacleMap.get(location.getAddress()));
                }
                if (locationTreasureMap.get(location.getAddress()) != null
                        && !locationTreasureMap.get(location.getAddress()).isEmpty()) {
                    location.addTreasure(locationTreasureMap.get(location.getAddress()));
                }
                if (arrowLocations.contains(location.getAddress())) {
                    location.addArrow();
                }
            }
        }

        map = copyMap;
        adjacency.clear();
        createAdjacencyList();
        player.reset();
        visitedLocations = new LinkedHashSet<>();
        visitedLocations.add(startLocation);
        gameState = GameState.PLAYING;
        canMove = true;
        if (hasMovingMonster) {
            berbalang.reset();
        }
    }

    @Override
    public boolean isWrapping() {
        return wrapping;
    }

    @Override
    public int getDegreeOfInterconnectivity() {
        return degreeOfInterconnectivity;
    }

    @Override
    public int getStartRow() {
        return startLocation.getRowNumber();
    }

    @Override
    public int getStartColumn() {
        return startLocation.getColumnNumber();
    }

    @Override
    public int getEndRow() {
        return endLocation.getRowNumber();
    }

    @Override
    public int getEndColumn() {
        return endLocation.getColumnNumber();
    }

    @Override
    public int getNumberOfRows() {
        return numberOfRows;
    }

    @Override
    public int getNumberOfColumns() {
        return numberOfColumns;
    }

    @Override
    public int getTreasurePercentage() {
        return treasurePercentage;
    }

    @Override
    public int getDifficulty() {
        return numberOfMonsters;
    }

    @Override
    public LocationAddress getBerbalangLocation() {
        return berbalang.getLocation();
    }

    @Override
    public int getPlayerHealth() {
        return player.getHealth();
    }

    @Override
    public int getNumberOfThieves() {
        return numberOfThieves;
    }

    @Override
    public int getNumberOfPits() {
        return numberOfPits;
    }

    @Override
    public boolean hasMovingMonster() {
        return hasMovingMonster;
    }

    @Override
    public ObstacleType jumpPlayer(MovementDirection movementDirection) {
        Location playerCurrentLocation = getLocationFromAddress(player.getCurrentLocation());
        if (!playerCurrentLocation.getOpenings().contains(movementDirection)) {
            throw new IllegalArgumentException("Player cannot jump " + movementDirection
                    + ", there is no opening available");
        }
        player.move(movementDirection);
        Location playerUpdatedLocation = getLocationFromAddress(player.getCurrentLocation());
        if (!playerUpdatedLocation.getOpenings().contains(movementDirection)) {
            player.move(movementDirection.getOpposite());
        }
        visitedLocations.add(player.getCurrentLocation());
        return movePlayer(movementDirection);
    }

    @Override
    public ObstacleType movePlayer(MovementDirection movementDirection) {
        if (getState() == GameState.QUIT || getState() == GameState.LOSE
                || getState() == GameState.WIN) {
            throw new IllegalStateException("Cannot move the player once the game has completed.");
        }

        if (!canMove) {
            throw new IllegalArgumentException("Cannot move the player away from this!");
        }

        Location playerCurrentLocation = getLocationFromAddress(player.getCurrentLocation());
        if (!playerCurrentLocation.getOpenings().contains(movementDirection)) {
            throw new IllegalArgumentException("Player cannot move " + movementDirection.toString()
                    .toLowerCase(Locale.ROOT) + ", there is no opening available");
        } else if (player.getCurrentLocation().equals(endLocation)
                && !playerCurrentLocation.getOtyugh().isAlive()) {
            throw new IllegalStateException("The game is over, the player already escaped the dungeon.");
        }

        if (playerCurrentLocation.getThief() != null) {
            playerCurrentLocation.makeThiefEscapeDungeon();
        }

        if (hasMovingMonster && berbalang.isAlive()) {
            moveBerbalang();
        }
        player.move(movementDirection);

        Location playerUpdatedLocation = getLocationFromAddress(player.getCurrentLocation());
        visitedLocations.add(playerUpdatedLocation.getAddress());
        if (hasMovingMonster && berbalang.getLocation().equals(playerUpdatedLocation.getAddress())
                && berbalang.isAlive()) {
            canMove = false;
        } else {
            if (playerUpdatedLocation.getOtyugh() != null) {
                Monster monster = playerUpdatedLocation.getOtyugh();
                if (monster.isAlive() && monster.getHealth() == 100) {
                    player.takeDamage(monster.attack());
                    gameState = GameState.LOSE;
                    return ObstacleType.OTYUGH;
                } else if (monster.isAlive() && monster.getHealth() == 50) {
                    boolean escape = randomGenerator.getRandomNumberBetween(0, 1) == 1;
                    if (!escape) {
                        player.takeDamage(monster.attack());
                        gameState = GameState.LOSE;
                    } else {
                        gameState = GameState.PLAYING;
                    }
                    return ObstacleType.INJURED_OTYUGH;
                } else if (playerCurrentLocation.getAddress().equals(endLocation)) {
                    gameState = GameState.WIN;
                    return ObstacleType.DEAD_OTYUGH;
                }
            }

            if (playerUpdatedLocation.getPit() != null) {
                gameState = GameState.LOSE;
                return ObstacleType.PIT;
            }

            if (playerUpdatedLocation.getThief() != null) {
                player.emptyTreasure();
                return ObstacleType.THIEF;
            }

            return ObstacleType.NO_OBSTACLE;
        }

        if (player.getHealth() == 0) {
            gameState = GameState.LOSE;
        }
        return ObstacleType.BERBALANG;
    }

    @Override
    public void hitBerbalang() {
        if (hasMovingMonster) {
            if (!player.getCurrentLocation().equals(berbalang.getLocation())) {
                throw new
                        IllegalStateException("There is no berbalang in this location, player cannot hit");
            } else if (!berbalang.isAlive()) {
                throw new IllegalStateException("The berbalang is already dead, you can move now!");
            }
            berbalang.takeDamage(player.getWeapon());
            if (!berbalang.isAlive()) {
                canMove = true;
            } else {
                player.takeDamage(berbalang.attack());
            }

            if (player.getHealth() == 0) {
                gameState = GameState.LOSE;
            }
        }
    }

    @Override
    public int getBerbalangHealth() {
        if (!hasMovingMonster) {
            throw new IllegalArgumentException("This Dungeon does not have a Barbalang");
        }
        return berbalang.getHealth();
    }

    @Override
    public String getPlayerDetails() {
        return player.toString();
    }

    @Override
    public Map<Collectible, Integer> getTreasureMap() {
        return player.getCollectedTreasureMap();
    }

    @Override
    public GameState getState() {
        return gameState;
    }

    @Override
    public List<Path> getConnectedPaths() {
        return new ArrayList<>(connectedPaths);
    }

    @Override
    public Location getPlayerCurrentLocation() {
        return new MazeLocation(getLocationFromAddress(player.getCurrentLocation()));
    }

    @Override
    public void pickup(Collectible collectible) {
        if (gameState != GameState.PLAYING) {
            throw new IllegalStateException("Game has already ended");
        }
        if (collectible == Collectible.ARROW) {
            collectArrow();
        } else {
            collectTreasure(collectible);
        }
    }

    @Override
    public ShootResult shootArrow(int distance, MovementDirection direction) {
        player.fireArrow(distance);
        if (!getLocationFromAddress(player.getCurrentLocation()).getOpenings().contains(direction)) {
            throw new IllegalArgumentException("There is no opening towards " + direction
                    + ", an arrow is wasted.");
        }

        Arrow arrow = new CrookedArrow(player.getCurrentLocation(), isWrapping(), map);

        arrow.shoot(distance, direction, player.getWeapon());

        if (getLocationFromAddress(arrow.getCurrentLocation()).getOtyugh() != null
                && arrow.getDistanceTravelled() == distance
                && getLocationFromAddress(arrow.getCurrentLocation()).getOtyugh().isAlive()) {
            Monster monster = getLocationFromAddress(arrow.getCurrentLocation()).getOtyugh();
            monster.takeDamage(arrow);
            return new ShootResult(true, arrow.getCurrentLocation());
        } else {
            return new ShootResult(false, arrow.getCurrentLocation());
        }
    }

    @Override
    public int detectSmell() {
        int smell = 0;

        Set<MovementDirection> currentLocationOpenings =
                getLocationFromAddress(player.getCurrentLocation()).getOpenings();

        for (MovementDirection currentLocationOpening : currentLocationOpenings) {
            Location neighbouringLocation =
                    getLocationFromDirection(currentLocationOpening, player.getCurrentLocation());
            if (neighbouringLocation.getOtyugh() != null
                    && neighbouringLocation.getOtyugh().isAlive()) {
                smell = smell + 2;
                break;
            }
            Set<MovementDirection> neighbouringLocationOpenings = neighbouringLocation.getOpenings();
            Set<Location> visitedNodes = new LinkedHashSet<>();
            for (MovementDirection neighbouringLocationOpening : neighbouringLocationOpenings) {
                Location twoAwayLocation =
                        getLocationFromDirection(neighbouringLocationOpening,
                                neighbouringLocation.getAddress());
                if (!visitedNodes.contains(twoAwayLocation) && twoAwayLocation.getOtyugh() != null
                        && twoAwayLocation.getOtyugh().isAlive()) {
                    visitedNodes.add(twoAwayLocation);
                    smell++;
                }
            }
        }
        return smell;
    }

    @Override
    public int detectWindLevel() {
        int wind = 0;
        Set<MovementDirection> currentLocationOpenings =
                getLocationFromAddress(player.getCurrentLocation()).getOpenings();
        for (MovementDirection currentLocationOpening : currentLocationOpenings) {
            Location neighbouringLocation =
                    getLocationFromDirection(currentLocationOpening, player.getCurrentLocation());
            if (neighbouringLocation.getPit() != null) {
                wind = wind + 1;
                break;
            }
        }
        return wind;
    }

    @Override
    public int getNumberOfArrows() {
        return player.getNumberOfArrowsAvailable();
    }

    @Override
    public Set<LocationAddress> getVisitedLocations() {
        return new LinkedHashSet<>(visitedLocations);
    }

    @Override
    public void quit() {
        gameState = GameState.QUIT;
    }

    private void validateParameters(int numberOfRows, int numberOfColumns,
                                    int degreeOfInterconnectivity, int treasurePercentage,
                                    int numberOfOtyughs, int numberOfThieves, int numberOfPits) {
        if (degreeOfInterconnectivity < 0 || degreeOfInterconnectivity
                > (calculateNumberOfPotentialPaths(numberOfRows, numberOfColumns, wrapping))) {
            throw new IllegalArgumentException("Degree of interconnectivity cannot be less than 0 or "
                    + "more than the minimum possible number of connections.");
        }

        if (numberOfColumns <= 0 || numberOfRows <= 0) {
            throw new IllegalArgumentException("Cannot create maze with zero or negative number "
                    + "of rows or columns.");
        }

        if (treasurePercentage > 100) {
            throw new IllegalArgumentException("Treasure percentage cannot be more than 100.");
        } else if (treasurePercentage < 0) {
            throw new IllegalArgumentException("Treasure percentage cannot be negative.");
        }

        if (numberOfColumns * numberOfRows < 10) {
            throw new IllegalArgumentException("There should at least be 10 locations in the maze.");
        }

        if (numberOfOtyughs <= 0) {
            throw new IllegalArgumentException("Difficulty is required to be a positive whole number");
        } else if (numberOfOtyughs > (numberOfRows * numberOfColumns)) {
            throw new IllegalArgumentException("Difficulty cannot be more than the total number "
                    + "of locations in the dungeon");
        }

        if (numberOfThieves > (numberOfColumns * numberOfRows) - 2 || numberOfThieves < 0) {
            throw new IllegalArgumentException("Number of thieves cannot be more than the number of"
                    + " locations or less than 0.");
        }

        if (numberOfPits > (numberOfColumns * numberOfRows) - 2 || numberOfPits < 0) {
            throw new IllegalArgumentException("Number of pits cannot be more than the number of"
                    + " locations or less than 0.");
        }
    }

    private void collectTreasure(Collectible collectible) {
        if (getLocationFromAddress(player.getCurrentLocation()).getTreasures().isEmpty()) {
            throw new IllegalStateException("There is no treasure in the current location.");
        }
        if (getLocationFromAddress(player.getCurrentLocation()).getTreasures().contains(collectible)) {
            player.collectTreasure(collectible);
            getLocationFromAddress(player.getCurrentLocation()).markTreasureCollected(collectible);
        } else {
            throw new IllegalStateException("There are no " + collectible + " in this location");
        }
    }

    private void collectArrow() {
        if (getLocationFromAddress(player.getCurrentLocation()).isHasArrow()) {
            player.addArrow();
            getLocationFromAddress(player.getCurrentLocation()).markArrowCollected();
        } else {
            throw new IllegalStateException("There are no arrows in this location");
        }
    }

    private int calculateNumberOfPotentialPaths(int r, int c, boolean isWrapping) {
        int noOfPotentialPaths = ((((r * c) - (r + c - 1)) * 2) + ((r - 1) + (c - 1)));
        if (isWrapping) {
            return noOfPotentialPaths + r + c;
        } else {
            return noOfPotentialPaths;
        }
    }

    private void generateEndLocation() {
        this.endLocation = indexOfCaves.get(randomGenerator.getRandomNumberBetween(0,
                indexOfCaves.size() - 1));
        if (getDistanceBetweenTwoLocations(startLocation, endLocation, adjacency)
                < MINIMUM_DISTANCE_BETWEEN_START_END) {
            generateEndLocation();
        }
    }

    private void generateMap(boolean setWrapping, int numberOfRows, int numberOfColumns,
                             int degreeOfInterconnectivity) {

        List<Path> potentialPaths = new ArrayList<>();

        for (int i = 0; i < numberOfRows; i++) {
            for (int j = 0; j < numberOfColumns; j++) {
                if (j + 1 < numberOfColumns) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i, j + 1));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                } else if (j + 1 >= numberOfColumns && setWrapping) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i, 0));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                }

                if (j - 1 >= 0) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i, j - 1));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                } else if (setWrapping) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i, numberOfColumns - 1));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                }

                if (i + 1 < numberOfRows) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i + 1, j));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                } else if (i + 1 >= numberOfRows && setWrapping) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(0, j));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                }

                if (i - 1 >= 0) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(i - 1, j));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                } else if (setWrapping) {
                    Path path = new Path(new LocationAddress(i, j),
                            new LocationAddress(numberOfRows - 1, j));
                    if (!potentialPaths.contains(path)) {
                        potentialPaths.add(path);
                    }
                }

                map[i][j] = new MazeLocation(i, j);
            }
        }

        generateConnectionsBetweenPaths(new ArrayList<>(potentialPaths), degreeOfInterconnectivity);

        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                copyMap[i][j] = new MazeLocation(map[i][j]);
            }
        }

        populateLocationsAndCavesList();
        addTreasureToMap();
        addArrowsToMap();
    }

    private void generateConnectionsBetweenPaths(List<Path> potentialPaths,
                                                 int degreeOfInterconnectivity) {
        List<Set<LocationAddress>> connectedLocationSets = new ArrayList<>();

        List<Path> remainderPaths = new ArrayList<>();

        while (!potentialPaths.isEmpty()) {
            Path randomPath = potentialPaths.get(randomGenerator.getRandomNumberBetween(0,
                    potentialPaths.size() - 1));
            if (checkPathBetweenLocations(connectedLocationSets, randomPath)) {
                remainderPaths.add(randomPath);
            } else {
                connectedPaths.add(randomPath);
            }
            potentialPaths.remove(randomPath);
        }

        if (degreeOfInterconnectivity != 0) {
            connectedPaths.addAll(randomGenerator.pickNRandom(remainderPaths, degreeOfInterconnectivity));
        }

        connectedPaths.forEach(this::applyPathsToLocation);
    }

    private boolean checkPathBetweenLocations(List<Set<LocationAddress>> connectedLocationSets,
                                              Path path) {

        for (int i = 0; i < connectedLocationSets.size(); i++) {
            if (connectedLocationSets.get(i).contains(path.getLocationOne())
                    && connectedLocationSets.get(i).contains(path.getLocationTwo())) {
                return true;
            } else if (connectedLocationSets.get(i).contains(path.getLocationOne())) {
                for (int j = 0; j < connectedLocationSets.size(); j++) {
                    if (connectedLocationSets.get(j).contains(path.getLocationTwo())) {
                        connectedLocationSets.get(i).addAll(connectedLocationSets.get(j));
                        connectedLocationSets.remove(connectedLocationSets.get(j));
                        return false;
                    }
                }
                connectedLocationSets.get(i).add(path.getLocationTwo());
                return false;
            } else if (connectedLocationSets.get(i).contains(path.getLocationTwo())) {
                for (int j = 0; j < connectedLocationSets.size(); j++) {
                    if (connectedLocationSets.get(j).contains(path.getLocationOne())) {
                        connectedLocationSets.get(i).addAll(connectedLocationSets.get(j));
                        connectedLocationSets.remove(connectedLocationSets.get(j));
                        return false;
                    }
                }
                connectedLocationSets.get(i).add(path.getLocationOne());
                return false;
            }
        }

        Set<LocationAddress> locationAddressSet = new LinkedHashSet<>();
        locationAddressSet.add(path.getLocationOne());
        locationAddressSet.add(path.getLocationTwo());
        connectedLocationSets.add(locationAddressSet);
        return false;
    }

    private void applyPathsToLocation(Path path) {
        int r1 = path.getLocationOne().getRowNumber();
        int c1 = path.getLocationOne().getColumnNumber();

        int r2 = path.getLocationTwo().getRowNumber();
        int c2 = path.getLocationTwo().getColumnNumber();

        if (isWrapping()) {
            if (r1 == 0 && r2 == numberOfRows - 1 && c1 == c2) {
                getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.NORTH);
                getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.SOUTH);
            } else if (r2 == 0 && r1 == numberOfRows - 1 && c1 == c2) {
                getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.SOUTH);
                getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.NORTH);
            }

            if (c1 == 0 && c2 == numberOfColumns - 1 && r1 == r2) {
                getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.WEST);
                getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.EAST);
            } else if (c2 == 0 && c1 == numberOfColumns - 1 && r1 == r2) {
                getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.EAST);
                getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.WEST);
            }
        }

        if ((r1 > r2) && !(r2 == 0 && r1 == numberOfRows - 1)) {
            getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.NORTH);
            getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.SOUTH);
        } else if ((r2 > r1) && !(r1 == 0 && r2 == numberOfRows - 1)) {
            getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.SOUTH);
            getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.NORTH);
        }

        if ((c1 > c2) && !(c2 == 0 && c1 == numberOfColumns - 1)) {
            getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.WEST);
            getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.EAST);
        } else if ((c2 > c1) && !(c1 == 0 && c2 == numberOfColumns - 1)) {
            getLocationFromAddress(path.getLocationOne()).addOpenings(MovementDirection.EAST);
            getLocationFromAddress(path.getLocationTwo()).addOpenings(MovementDirection.WEST);
        }

    }

    private void populateLocationsAndCavesList() {
        indexOfCaves = new ArrayList<>();

        indexOfLocations = new ArrayList<>();

        for (int i = 0; i < map.length; i++) {
            Location[] locations = map[i];
            for (int j = 0; j < locations.length; j++) {
                indexOfLocations.add(new LocationAddress(i, j));
                Location location = locations[j];
                if (location.getType() == LocationType.CAVE) {
                    indexOfCaves.add(new LocationAddress(i, j));
                }
            }
        }
    }

    private void addTreasureToMap() {

        int minimumCavesWithTreasure = Math.round((float) treasurePercentage / 100
                * indexOfCaves.size());

        List<LocationAddress> cavesWithTreasures = randomGenerator.pickNRandom(indexOfCaves,
                minimumCavesWithTreasure);

        List<Collectible> potentialCollectibles
                = List.of(Collectible.DIAMONDS, Collectible.RUBIES, Collectible.SAPPHIRES);

        cavesWithTreasures.forEach(locationAddress -> {
            getLocationFromAddress(locationAddress)
                    .addTreasure(new LinkedHashSet<>(randomGenerator.pickNRandom(potentialCollectibles,
                            randomGenerator.getRandomNumberBetween(1, 3))));
        });

    }

    private void addArrowsToMap() {
        int cavesWithArrows = Math.round((float) treasurePercentage / 100
                * indexOfLocations.size());

        List<LocationAddress> locationsWithArrows = randomGenerator.pickNRandom(indexOfLocations,
                cavesWithArrows);

        locationsWithArrows.forEach(location -> getLocationFromAddress(location).addArrow());
    }

    private void addMonsterToDungeon() {
        if (numberOfMonsters != 1) {
            List<LocationAddress> cavesWithMonsters = new ArrayList<>(indexOfCaves);
            cavesWithMonsters.remove(startLocation);
            cavesWithMonsters.remove(endLocation);
            int numberOfMonstersToBeAddedToDungeon;
            if (numberOfMonsters > cavesWithMonsters.size()) {
                numberOfMonstersToBeAddedToDungeon = cavesWithMonsters.size();
            } else {
                numberOfMonstersToBeAddedToDungeon = numberOfMonsters - 1;
            }
            cavesWithMonsters = randomGenerator.pickNRandom(cavesWithMonsters,
                    numberOfMonstersToBeAddedToDungeon);
            cavesWithMonsters.forEach(address ->
                    getLocationFromAddress(address).addMonster(new Otyugh(100, address)));
        }
        getLocationFromAddress(endLocation).addMonster(new Otyugh(100, endLocation));
    }

    private void moveBerbalang() {

        Map<MovementDirection, Integer> directionDistanceMap = new LinkedHashMap<>();

        getLocationFromAddress(berbalang.getLocation()).getOpenings().forEach(direction ->
                directionDistanceMap.put(direction,
                        getDistanceBetweenTwoLocations(player.getCurrentLocation(),
                                getLocationFromDirection(direction, berbalang.getLocation())
                                        .getAddress(), adjacency)));

        if (Collections.min(directionDistanceMap.values()) != 0) {
            berbalang.move(getMinKey(directionDistanceMap, MovementDirection.NORTH,
                    MovementDirection.SOUTH, MovementDirection.EAST, MovementDirection.WEST));
        }


    }

    private MovementDirection getMinKey(Map<MovementDirection, Integer> map,
                                        MovementDirection... keys) {
        Optional<Map.Entry<MovementDirection, Integer>> directionOptional = map.entrySet().stream()
                .filter(p -> Arrays.asList(keys).contains(p.getKey()))
                .min(Comparator.comparingInt(Map.Entry::getValue));
        MovementDirection direction = keys[0];
        if (directionOptional.isPresent()) {
            direction = directionOptional.get().getKey();
        }
        return direction;
    }

    private Location getLocationFromDirection(MovementDirection direction, LocationAddress address) {
        LocationAddress currentLocation;
        switch (direction) {
            case WEST: {
                if (wrapping && address.getColumnNumber() == 0) {
                    currentLocation = new LocationAddress(address.getRowNumber(),
                            numberOfColumns - 1);
                } else {
                    currentLocation
                            = new LocationAddress(address.getRowNumber(),
                            address.getColumnNumber() - 1);
                }
            }
            break;

            case EAST: {
                if (wrapping && address.getColumnNumber() == numberOfColumns - 1) {
                    currentLocation = new LocationAddress(address.getRowNumber(), 0);
                } else {
                    currentLocation
                            = new LocationAddress(address.getRowNumber(),
                            address.getColumnNumber() + 1);
                }

            }
            break;

            case SOUTH: {
                if (wrapping && address.getRowNumber() == numberOfRows - 1) {
                    currentLocation = new LocationAddress(0, address.getColumnNumber());
                } else {
                    currentLocation
                            = new LocationAddress(address.getRowNumber() + 1,
                            address.getColumnNumber());
                }
            }
            break;

            case NORTH: {
                if (wrapping && address.getRowNumber() == 0) {
                    currentLocation = new LocationAddress(numberOfRows - 1,
                            address.getColumnNumber());
                } else {
                    currentLocation = new LocationAddress(address.getRowNumber() - 1,
                            address.getColumnNumber());
                }
            }
            break;

            default: {
                currentLocation = new LocationAddress(address.getRowNumber(), address.getColumnNumber());
            }
            break;
        }

        return map[currentLocation.getRowNumber()][currentLocation.getColumnNumber()];
    }

    private Location getLocationFromAddress(LocationAddress address) {
        return map[address.getRowNumber()][address.getColumnNumber()];
    }

    private int getDistanceBetweenTwoLocations(LocationAddress start, LocationAddress end,
                                               Map<LocationAddress, Set<LocationAddress>> adjacency) {
        if (start.equals(end)) {
            return 0;
        }

        Map<LocationAddress, Set<LocationAddress>> adjacencyMap = new LinkedHashMap<>(adjacency);
        LinkedList<LocationAddress> queue = new LinkedList<>();
        List<LocationAddress> visited = new ArrayList<>();
        List<LocationAddress> traversed = new ArrayList<>();

        visited.add(start);
        queue.add(start);

        while (queue.size() != 0) {
            start = queue.poll();
            traversed.add(start);
            for (LocationAddress locationAddress : adjacencyMap.get(start)) {
                if (!visited.contains(locationAddress)) {
                    visited.add(locationAddress);
                    queue.add(locationAddress);
                }
            }
        }

        int endIndex = traversed.indexOf(end);
        List<LocationAddress> path = new ArrayList<>();
        path.add(traversed.get(endIndex));
        LocationAddress last = traversed.get(endIndex);
        for (int i = endIndex - 1; i >= 0; i--) {
            if (adjacencyMap.get(last).contains(traversed.get(i))) {
                path.add(traversed.get(i));
                last = traversed.get(i);
            }
        }

        return (path.size() - 1);
    }

    private void createAdjacencyList() {
        for (Path path : connectedPaths) {
            Set<LocationAddress> adjacencyList;

            if (adjacency.get(path.getLocationOne()) != null) {
                adjacencyList = adjacency.get(path.getLocationOne());
            } else {
                adjacencyList = new LinkedHashSet<>();
            }

            adjacencyList.add(path.getLocationTwo());
            adjacency.put(path.getLocationOne(), adjacencyList);

            if (adjacency.get(path.getLocationTwo()) != null) {
                adjacencyList = adjacency.get(path.getLocationTwo());
            } else {
                adjacencyList = new LinkedHashSet<>();
            }

            adjacencyList.add(path.getLocationOne());
            adjacency.put(path.getLocationTwo(), adjacencyList);
        }
    }
}
